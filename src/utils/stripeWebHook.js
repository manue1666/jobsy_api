import stripePackage from "stripe";
import { Types } from "mongoose";
import { ServiceModel } from "../Models/Service_Model.js";
import { BOOST_PLANS } from "./constants.js";

const stripe = stripePackage(process.env.STRIPE_SECRET_KEY, {
  apiVersion: "2025-07-30.basil",
});

export const handleStripeWebhook = async (req, res) => {
  const sig = req.headers["stripe-signature"];
  if (!sig) return res.status(401).json({ error: "Firma no proporcionada" });

  let event;
  try {
    event = stripe.webhooks.constructEvent(
      req.body,
      sig,
      process.env.STRIPE_WEBHOOK_SECRET
    );
  } catch (err) {
    console.error("‚ùå Error verificando webhook:", err.message);
    return res.status(400).json({ error: `Webhook Error: ${err.message}` });
  }

  console.log("üîî Evento recibido:", event.type);

  // Manejar eventos de pago exitoso
  if (
    event.type === "payment_intent.succeeded" ||
    event.type === "charge.succeeded"
  ) {
    // ‚úÖ EXTRAER METADATOS
    let metadata = {};
    if (event.type === "payment_intent.succeeded") {
      metadata = event.data.object.metadata || {};
      console.log("üí∞ Procesando payment_intent.succeeded");
    } else if (event.type === "charge.succeeded") {
      metadata = event.data.object.metadata || {};
      console.log("üí≥ Procesando charge.succeeded");
    }

    const { serviceId, planId } = metadata;
    console.log(
      "üìã Metadata extra√≠da - ServiceId:",
      serviceId,
      "PlanId:",
      planId
    );

    // ‚úÖ VALIDACI√ìN ROBUSTA DE METADATOS
    if (!serviceId || !planId) {
      console.error("‚ùå Metadata faltante o incompleta");
      return res.status(400).json({ error: "Metadata inv√°lida" });
    }

    if (!Types.ObjectId.isValid(serviceId)) {
      console.error("‚ùå ObjectId inv√°lido:", serviceId);
      return res.status(400).json({ error: "ServiceId inv√°lido" });
    }

    if (!BOOST_PLANS[planId]) {
      console.error("‚ùå Plan no v√°lido:", planId);
      return res.status(400).json({ error: "Plan no v√°lido" });
    }

    try {
      console.log("üîÑ Actualizando servicio en BD...");

      const selectedPlan = BOOST_PLANS[planId];
      const promotionDuration = selectedPlan.duration;
      const promotedUntil = new Date(Date.now() + promotionDuration);

      const updatedService = await ServiceModel.findByIdAndUpdate(
        serviceId,
        {
          isPromoted: true,
          promotedUntil: promotedUntil,
          promotionPlan: planId,
        },
        { new: true, runValidators: true }
      );

      if (!updatedService) {
        console.error("‚ùå Servicio no encontrado:", serviceId);
        return res.status(404).json({ error: "Servicio no encontrado" });
      }

      console.log("‚úÖ Servicio actualizado exitosamente:", {
        serviceId: updatedService._id,
        isPromoted: updatedService.isPromoted,
        promotedUntil: updatedService.promotedUntil,
        promotionPlan: updatedService.promotionPlan,
      });
    } catch (dbError) {
      console.error("‚ùå Error de base de datos:", dbError);
      // ‚≠ê REVERTIR EL PAGO SI FALLA LA BD
      try {
        const paymentIntentId = event.data.object.id;
        await stripe.refunds.create({
          payment_intent: paymentIntentId,
          reason: "failed_service_activation",
        });
        console.log("‚ö†Ô∏è Pago revertido por fallo en BD");
      } catch (refundError) {
        console.error(
          "‚ùå Error cr√≠tico: No se pudo revertir el pago:",
          refundError
        );
      }
    }
  }

  // Manejar cancelaciones
  if (event.type === "payment_intent.canceled") {
    const paymentIntent = event.data.object;
    const { serviceId } = paymentIntent.metadata || {};

    if (serviceId) {
      try {
        await ServiceModel.findByIdAndUpdate(serviceId, {
          isPromoted: false,
          promotedUntil: null,
          promotionPlan: null,
        });
        console.log("üîÑ Boost revertido por cancelaci√≥n de pago");
      } catch (error) {
        console.error("‚ùå Error revertiendo boost:", error);
      }
    }
  }

  res.json({ received: true });
};
